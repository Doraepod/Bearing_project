 #include "include_file.h"
 #include "go_external_ADC.h"
 #include "i2c.h"
 
 uint16_t value1[DD]; // массив данных с 4-х датчиков параметр DD задан в include_file
 uint16_t value;      // значение для исправления ошибки при работе с АЦП
 int R;               // значений для передачи управляющих команд на АЦП
 float otvet;		  // значения для выполнения расчетов можно сократить!!!
 float temp;          // значения для выполнения расчетов можно сократить!!!
 int lastotvet;       // значения для выполнения расчетов можно сократить!!!
 int otvetxy[DD];     // значения для выполнения расчетов можно сократить!!!
 int y;				  // значение для вывода данных по USART
 int non=0;			  // для корректной записи значений в массив value1[DD]

//=======================================================================
//					       инициализация внешнего ADC
//=======================================================================

void external_ADC_init(void)
{
	i2c_init();
	i2c_start();
	R = i2c_send_byte(0b10010000);//адрес ацп + команда на запись
	R = i2c_send_byte(0b01000100);//команда для ацп
	i2c_stop();
	
}

//=======================================================================
//                    исправление ошибки
//    Возникла ошибка из-за которой первым отправляется значение, которое было в памяти до первого считанного значения
//    если устранить проблему блок можно удалить. Если нет он включается вместе с i2c_ADC один раз в начале программы
//=======================================================================

void external_ADC_war(void)
{
	i2c_init();
	i2c_start();
	R = i2c_send_byte(0b10010001);//адрес ацп + команда на чтение
	value = i2c_read_byte(NACK);
	i2c_stop();
}

//=======================================================================
//                     считывание дынных с АЦП
//      в первом случае данные записываются в массив для отправки по USART на ПК
//      единажды считываются четыре значения с АЦП, следующий съем значений перезаписывает данные              
//=======================================================================

void Data_in(void)
{
	i2c_init();
	i2c_start();
	R = i2c_send_byte(0b10010001);//адрес ацп + команда на чтение
	int you;
	for (you = 0; you < KOL-1; you++)
	{
		value1[non] = i2c_read_byte(ACK);
		non++;
	}
	value1[non] = i2c_read_byte(NACK);
	non++;
	i2c_stop();
}

/*
void Data_in(void)
{
	i2c_init();
	i2c_start();
	R = i2c_send_byte(0b10010001);//адрес ацп + команда на чтение
	for (int you = 0; you < KOL-1; you++)
	{
		value1[you] = i2c_read_byte(ACK);
	}
	value1[KOL-1] = i2c_read_byte(NACK);
	i2c_stop();
}*/

//=======================================================================
//            вывод значение полученных от АЦП через USART на ПК
//=======================================================================

void Data_out(void)
{
	int you;
	for (you = 0; you < DD; you++)
	{
		temp = (((float)value1[you]) / 255 ) * 10; // значение напряжения
		otvet = ( (temp - 0.11783) / 2.365 ) + 0.45;  // значение расстояния от датчика до цапфы
		lastotvet = otvet * 1000;                    // для правильного вывода значений
		otvetxy[you] = lastotvet;
	}
	
/*	for (you = 0; you < DD; you++)              // вывод значений расстояния с каждого датчика 
	{
		int pop = otvetxy[you];
		usart_send_int(pop);
	}*/
	
	for (you = 0; you < DD; you+=4)             // вывод значения двух координат
	{
		y=(otvetxy[you]-otvetxy[you+1])/2;
		y= 2000 + y;
		usart_send_int(y);
		y=(otvetxy[you+2]-otvetxy[you+3])/2;
		y=  2000 + y;
		usart_send_int(y);
	}
}